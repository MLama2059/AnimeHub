@page "/my-watchlist"
@using AnimeHub.Shared.Models.Dtos.Anime
@using AnimeHub.Shared.Models.Dtos.UserAnime
@using AnimeHub.Shared.Models.Enums
@using AnimeHubClient.Services
@using AnimeHubClient.Extensions
@using Microsoft.AspNetCore.Authorization
@using Microsoft.Extensions.Configuration
@inject IWatchlistService WatchlistService
@inject ISnackbar Snackbar
@inject NavigationManager NavManager
@inject IConfiguration Configuration
@attribute [Authorize]

<MudCard Elevation="4" Class="mt-4">
    <MudCardHeader>
        <CardHeaderContent>
            <MudText Align="Align.Center" Typo="Typo.h4" Class="fw-bold">My Watchlist</MudText>
        </CardHeaderContent>
    </MudCardHeader>

    <MudCardContent>
        @if (IsLoading)
        {
            <div class="py-4 text-center"><MudProgressCircular Indeterminate="true" /></div>
        }
        else
        {
            <MudTable Items="@WatchlistItems"
                      FixedHeader="false"
                      Hover="true"
                      Striped="true"
                      Breakpoint="Breakpoint.Sm"
                      LoadingProgressColor="Color.Primary">

                <ToolBarContent>
                    <MudText Typo="Typo.h6">@WatchlistItems.Count() Items</MudText>
                    <MudSpacer />
                    <MudTextField T="string" 
                                  Placeholder="Search by Title" 
                                  Adornment="Adornment.Start" 
                                  AdornmentIcon="@Icons.Material.Filled.Search"
                                  Immediate="true"
                                  Clearable="true"
                                  Style="max-width:300px;" 
                                  Value="SearchTerm"
                                  ValueChanged="@(async (v) => await OnSearch(v))" />
                </ToolBarContent>

                <HeaderContent>
                    <MudTh Style="width: 100px;">Image</MudTh>
                    <MudTh><MudTableSortLabel SortLabel="Title" T="UserAnimeReadDto">Title</MudTableSortLabel></MudTh>
                    <MudTh Style="width: 200px;">Watch Status</MudTh>
                    <MudTh Style="width:1%;">Actions</MudTh>
                </HeaderContent>

                <RowTemplate>
                    <MudTd DataLabel="Image" Style="width: 100px;">
                        @if (!string.IsNullOrEmpty(context.ImageUrl))
                        {
                            <MudImage Src="@($"{ApiBaseUrl}{context.ImageUrl.Replace("\\", "/")}")" 
                                      Alt="@context.Title" 
                                      Height="70" 
                                      Style="max-width: 100%; object-fit: cover; aspect-ratio: 1/1.4;" 
                                      Class="rounded-sm" />
                        }
                    </MudTd>
                    <MudTd DataLabel="Title">
                        <MudLink Href="@($"/anime/{context.AnimeId}")" Typo="Typo.body1" Color="Color.Primary">
                            @context.Title
                        </MudLink>
                    </MudTd>
                    <MudTd DataLabel="Watch Status">
                        @* Implement the User Watch Status Dropdown *@
                        <MudSelect T="WatchStatus" 
                                   Variant="Variant.Outlined"
                                   Margin="Margin.Dense"
                                   Value="context.WatchStatus" 
                                   ValueChanged="((WatchStatus newStatus) => UpdateWatchStatus(context.AnimeId, newStatus, context))">
                            
                            @foreach (WatchStatus statusValue in Enum.GetValues(typeof(WatchStatus)))
                            {
                                <MudSelectItem T="WatchStatus" Value="statusValue">
                                    @statusValue.GetDisplayName()
                                </MudSelectItem>
                            }
                        </MudSelect>
                    </MudTd>
                    <MudTd DataLabel="Actions" Style="white-space:nowrap;">
                        <MudIconButton OnClick="() => RemoveAnime(context.AnimeId, context.Title)" 
                                       Icon="@Icons.Material.Filled.Delete" 
                                       Color="Color.Error" 
                                       Size="Size.Medium"
                                       Title="Remove from Watchlist" />
                    </MudTd>
                </RowTemplate>

                <NoRecordsContent>
                    <MudText>You have no anime in your watchlist yet.</MudText>
                </NoRecordsContent>
            </MudTable>
        }
    </MudCardContent>
</MudCard>

@code {
    private List<UserAnimeReadDto> AllWatchlistItems = new();

    // Filtered list for the MudTable
    private IEnumerable<UserAnimeReadDto> WatchlistItems => AllWatchlistItems.Where(
        a => string.IsNullOrEmpty(SearchTerm) || a.Title.Contains(SearchTerm, StringComparison.OrdinalIgnoreCase)
    ).ToList();

    private string SearchTerm { get; set; } = string.Empty;
    private bool IsLoading = true;

    // Helper property to get Base URL and handle path separators
    private string ApiBaseUrl => Configuration["ApiBaseUrl"] ?? "";

    protected override async Task OnInitializedAsync()
    {
        await LoadWatchlist();
    }

    private async Task LoadWatchlist()
    {
        IsLoading = true;
        try
        {
            AllWatchlistItems = (await WatchlistService.GetMyWatchListAsync())
                .OfType<UserAnimeReadDto>() // Use OfType for safety if it returns object/interface
                .ToList();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading watchlist: {ex.Message}", Severity.Error);
        }
        finally
        {
            IsLoading = false;
        }
    }

    private async Task UpdateWatchStatus(int animeId, WatchStatus newStatus, UserAnimeReadDto item)
    {
        // Store the old status in case of failure
        var oldStatus = item.WatchStatus;

        // Update the local item immediately
        item.WatchStatus = newStatus;
        StateHasChanged();

        // Avoid setting IsLoading = true globally, as it blocks the whole page.
        try
        {
            var success = await WatchlistService.UpdateWatchStatusAsync(animeId, newStatus);

            if (success)
            {
                Snackbar.Add($"Status updated.", Severity.Success);
            }
            else
            {
                // Revert status change on API failure
                item.WatchStatus = oldStatus;
                StateHasChanged();
                Snackbar.Add($"Failed to update status.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            // Revert status change on exception
            item.WatchStatus = oldStatus;
            StateHasChanged();
            Snackbar.Add($"An error occurred while updating status: {ex.Message}", Severity.Error);
        }
    }

    private async Task RemoveAnime(int id, string title)
    {
        // Simple confirmation
        if (!await PromptRemoveConfirmation(title)) return;
        
        // Use a local loading state or a proper MudDialog for confirmation/loading
        try
        {
            var success = await WatchlistService.RemoveFromWatchlistAsync(id);
            
            if (success)
            {
                Snackbar.Add($"{title} removed from your watchlist.", Severity.Success);
                await LoadWatchlist();
            }
            else
            {
                Snackbar.Add($"Failed to remove {title}.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Removal error: {ex.Message}", Severity.Error);
        }
    }
    
    // Placeholder for simple confirmation
    private Task<bool> PromptRemoveConfirmation(string title)
    {
        // For a real application, replace this with a MudDialog confirmation
        return Task.FromResult(true); 
    }

    private async Task OnSearch(string text)
    {
        SearchTerm = text;
        StateHasChanged();
    }
}