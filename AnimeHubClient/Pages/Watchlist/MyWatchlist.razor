@page "/my-watchlist"
@using AnimeHub.Shared.Models.Dtos.Anime
@using AnimeHub.Shared.Models.Dtos.UserAnime
@using AnimeHub.Shared.Models.Enums
@using AnimeHubClient.Services
@using AnimeHubClient.Extensions
@using AnimeHubClient.Shared
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.Extensions.Configuration
@inject IWatchlistService WatchlistService
@inject ISnackbar Snackbar
@inject IDialogService Dialog
@inject NavigationManager NavManager
@inject IConfiguration Configuration

<AuthorizeView>
    <Authorized>
        <MudCard Elevation="4" Class="mt-4">
            <MudCardHeader>
                <CardHeaderContent>
                    <MudText Align="Align.Center" Typo="Typo.h4" Class="fw-bold">My Watchlist</MudText>
                </CardHeaderContent>
            </MudCardHeader>

            <MudCardContent>
                <div class="d-flex justify-content-between align-items-center mb-4">
                    <MudText Typo="Typo.h6" Class="d-inline-block">@TotalItems Items</MudText>

                    <div class="d-flex align-items-center gap-4">
                        <MudTextField T="string"
                                      Placeholder="Search by Title"
                                      Adornment="Adornment.Start"
                                      AdornmentIcon="@Icons.Material.Filled.Search"
                                      Immediate="true"
                                      Clearable="true"
                                      Style="max-width:300px;"
                                      Value="SearchTerm"
                                      ValueChanged="@(async (v) => await OnSearch(v))" />

                        <MudSelect T="WatchStatus ?"
                                   Label="Filter by Status"
                                   Variant="Variant.Outlined"
                                   Clearable="true"
                                   Style="width:200px;"
                                   Value="StatusFilter"
                                   ValueChanged="@(async (v) => await OnStatusFilterChanged(v))">

                            @* <MudSelectItem T="WatchStatus?">All Statuses</MudSelectItem> *@
                            @foreach (WatchStatus? statusValue in Enum.GetValues(typeof(WatchStatus)))
                            {
                                <MudSelectItem T="WatchStatus ?" Value="statusValue">
                                    @statusValue.GetDisplayName()
                                </MudSelectItem>
                            }
                        </MudSelect>
                    </div>
                    
                </div>

                <MudTable T="UserAnimeReadDto"
                          ServerData="ServerReload"
                          FixedHeader="false"
                          Hover="true"
                          Striped="true"
                          Breakpoint="Breakpoint.Sm"
                          LoadingProgressColor="Color.Primary"
                          @ref="MudTable">

                    <HeaderContent>
                        <MudTh Style="width: 100px;">Image</MudTh>
                        <MudTh><MudTableSortLabel SortLabel="Title" T="UserAnimeReadDto">Title</MudTableSortLabel></MudTh>
                        <MudTh Style="width: 200px;">Watch Status</MudTh>
                        <MudTh Style="width:1%;">Actions</MudTh>
                    </HeaderContent>

                    <RowTemplate Context="rowContext">
                        <MudTd DataLabel="Image" Style="width: 100px;">
                            @if (!string.IsNullOrEmpty(rowContext.ImageUrl))
                            {
                                <MudImage Src="@($"{ApiBaseUrl}{rowContext.ImageUrl.Replace("\\", "/")}")"
                                          Alt="@rowContext.Title"
                                          Height="70"
                                          Style="max-width: 100%; object-fit: cover; aspect-ratio: 1/1.4;"
                                          Class="rounded-sm" />
                            }
                        </MudTd>
                        <MudTd DataLabel="Title">
                            <MudLink Href="@($"/anime/{rowContext.AnimeId}")" Typo="Typo.body1" Color="Color.Primary">
                                @rowContext.Title
                            </MudLink>
                        </MudTd>
                        <MudTd DataLabel="Watch Status">
                            @* Implement the User Watch Status Dropdown *@
                            <MudSelect T="WatchStatus"
                                       Variant="Variant.Outlined"
                                       Margin="Margin.Dense"
                                       Value="rowContext.WatchStatus"
                                       ValueChanged="((WatchStatus newStatus) => UpdateWatchStatus(rowContext.AnimeId, newStatus, rowContext))">

                                @foreach (WatchStatus statusValue in Enum.GetValues(typeof(WatchStatus)))
                                {
                                    <MudSelectItem T="WatchStatus" Value="statusValue">
                                        @statusValue.GetDisplayName()
                                    </MudSelectItem>
                                }
                            </MudSelect>
                        </MudTd>
                        <MudTd DataLabel="Actions" Style="white-space:nowrap;">
                            <MudIconButton OnClick="() => RemoveAnime(rowContext.AnimeId, rowContext.Title)"
                                           Icon="@Icons.Material.Filled.Delete"
                                           Color="Color.Error"
                                           Size="Size.Medium" />
                        </MudTd>
                    </RowTemplate>

                    <NoRecordsContent>
                        <MudText>No data available.</MudText>
                    </NoRecordsContent>

                    <LoadingContent>
                        <div class="py-4 text-center">
                            <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
                        </div>
                    </LoadingContent>

                    <PagerContent>
                        <MudTablePager />
                    </PagerContent>
                </MudTable>
            </MudCardContent>
        </MudCard>
    </Authorized>
    <NotAuthorized>
        <div class="d-flex justify-content-center mt-5">
            <MudAlert Severity="Severity.Info" Class="p-2">
                <MudLink Href="/login" Typo="Typo.body2" Class="fw-bold">Log in</MudLink> to view watchlist!
            </MudAlert>
        </div>
    </NotAuthorized>
</AuthorizeView>


@code {
    private MudTable<UserAnimeReadDto>? MudTable;
    private string SearchTerm { get; set; } = string.Empty;
    private WatchStatus? StatusFilter { get; set; } // New filter property
    private int TotalItems { get; set; }

    private Dictionary<string, string> SortMapping = new()
    {
        {"Title", "title"},
        {"DateAdded", "dateadded"},
    };

    // Helper property to get Base URL and handle path separators
    private string ApiBaseUrl => Configuration["ApiBaseUrl"] ?? "";

    private async Task<TableData<UserAnimeReadDto>> ServerReload(TableState state, CancellationToken cancellationToken)
    {
        int pageNumber = state.Page + 1;
        int pageSize = state.PageSize;

        string orderBy = "dateadded_desc"; // Default sort
        if (!string.IsNullOrEmpty(state.SortLabel) && SortMapping.ContainsKey(state.SortLabel))
        {
            orderBy = SortMapping[state.SortLabel];

            if (state.SortDirection == SortDirection.Descending)
            {
                orderBy += "_desc";
            }
        }

        // 1. Build Query Parameters
        var queryParams = new Dictionary<string, string?>
        {
            {"pageNumber", pageNumber.ToString()},
            {"pageSize", pageSize.ToString()},
            {"orderBy", orderBy}
        };

        if (!string.IsNullOrWhiteSpace(SearchTerm))
        {
            queryParams.Add("filterOn", "Title");
            queryParams.Add("filterQuery", SearchTerm);
        }

        if (StatusFilter.HasValue)
        {
            queryParams.Add("statusFilter", ((int)StatusFilter.Value).ToString());
        }

        try
        {
            // 2. Call the service (You must update IWatchlistService to accept queryParams)
            var (items, metadata) = await WatchlistService.GetPagedWatchlistAsync(queryParams, cancellationToken);

            TotalItems = metadata?.TotalCount ?? 0;

            if (metadata != null)
            {
                StateHasChanged();
            }

            return new TableData<UserAnimeReadDto>() { TotalItems = TotalItems, Items = items ?? new List<UserAnimeReadDto>() };
        }
        catch (OperationCanceledException)
        {
            // request was cancelled; return empty result
            return new TableData<UserAnimeReadDto>() { TotalItems = 0, Items = new List<UserAnimeReadDto>() };
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error loading watchlist.");
            // Snackbar.Add($"Error loading watchlist: {ex.Message}", Severity.Error);
            return new TableData<UserAnimeReadDto>() { TotalItems = 0, Items = new List<UserAnimeReadDto>() };
        }
    }

    private async Task OnSearch(string text)
    {
        SearchTerm = text;
        // Trigger data reload
        await MudTable!.ReloadServerData();
    }

    private async Task OnStatusFilterChanged(WatchStatus? status)
    {
        StatusFilter = status;
        // Trigger data reload
        if (MudTable != null)
        {
            // When searching, reset to page 0 to show results immediately
            MudTable.CurrentPage = 0;
            await MudTable.ReloadServerData();
        }
    }

    private async Task UpdateWatchStatus(int animeId, WatchStatus newStatus, UserAnimeReadDto item)
    {
        // Store the old status in case of failure
        var oldStatus = item.WatchStatus;

        // Update the local item immediately
        item.WatchStatus = newStatus;
        StateHasChanged();

        // Avoid setting IsLoading = true globally, as it blocks the whole page.
        try
        {
            var success = await WatchlistService.UpdateWatchStatusAsync(animeId, newStatus);

            if (success)
            {
                Snackbar.Add($"Status updated.", Severity.Success);
                StateHasChanged();
            }
            else
            {
                // Revert status change on API failure
                item.WatchStatus = oldStatus;
                StateHasChanged();
                Snackbar.Add($"Failed to update status.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            // Revert status change on exception
            item.WatchStatus = oldStatus;
            StateHasChanged();
            Snackbar.Add($"An error occurred while updating status: {ex.Message}", Severity.Error);
        }
    }

    private async Task RemoveAnime(int id, string title)
    {
        var parameters = new DialogParameters<ConfirmationDialog>
        {
            { x => x.ContentText, "Are you sure you want to delete?"  },
            { x => x.ButtonText, "Delete" }
        };

        var options = new DialogOptions
        {
            CloseButton = true,
            MaxWidth = MaxWidth.ExtraLarge,
            FullWidth = false,
        };

        var dialog = await Dialog.ShowAsync<ConfirmationDialog>("Confirm Delete", parameters, options);
        var result = await dialog.Result;
        
        // Use a local loading state or a proper MudDialog for confirmation/loading
        if (result != null && !result.Canceled)
        {
            var success = await WatchlistService.RemoveFromWatchlistAsync(id);
            
            if (success)
            {
                Snackbar.Add($"Anime removed from your watchlist.", Severity.Success);
                await MudTable!.ReloadServerData();
            }
            else
            {
                Snackbar.Add($"Failed to remove anime.", Severity.Error);
            }
        }
    }
}