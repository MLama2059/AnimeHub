@page "/anime"
@using AnimeHub.Shared.Models.Dtos
@using AnimeHub.Shared.Models.Dtos.Anime
@using AnimeHubClient.Shared
@using Microsoft.AspNetCore.WebUtilities
@inject HttpClient Http
@inject IDialogService Dialog
@inject ISnackbar Snackbar

<MudCard Elevation="4" Class="mt-4">
    <MudCardHeader>
        <CardHeaderContent>
            <MudText Align="Align.Center" Typo="Typo.h4" Class="fw-bold">Anime List</MudText>
        </CardHeaderContent>
    </MudCardHeader>

    <MudCardContent>
        <div class="d-flex justify-content-between align-items-center mb-4">
            <MudTextField T="string"
                            Placeholder="Search anime"
                            Adornment="Adornment.Start"
                            AdornmentIcon="@Icons.Material.Filled.Search"
                            Immediate="true"
                            Clearable="true"
                            Style="max-width:300px;"
                            Value="SearchTerm"
                            ValueChanged="@(async (v) => await OnSearch(v))" />

            <MudButton Href="anime/create"
                        StartIcon="@Icons.Material.Filled.AddTask"
                        Variant="Variant.Filled"
                        Color="Color.Primary">
                Add New Anime
            </MudButton>
        </div>

        <MudTable ServerData="ServerReload"
                  FixedHeader="true"
                  Height="450px"
                  Hover="true"
                  Bordered="true"
                  Striped="true"
                  Breakpoint="Breakpoint.Sm"
                  LoadingProgressColor="Color.Primary"
                  @ref="MudTable">

            <HeaderContent>
                <MudTh><MudTableSortLabel SortLabel="Title" T="AnimeListReadDto">Title</MudTableSortLabel></MudTh>
                <MudTh><MudTableSortLabel SortLabel="Episodes" T="AnimeListReadDto">Episodes</MudTableSortLabel></MudTh>
                <MudTh><MudTableSortLabel SortLabel="PremieredYear" T="AnimeListReadDto">Priemered</MudTableSortLabel></MudTh>
                <MudTh><MudTableSortLabel SortLabel="Status" T="AnimeListReadDto">Status</MudTableSortLabel></MudTh>
                <MudTh><MudTableSortLabel SortLabel="CategoryName" T="AnimeListReadDto">Category</MudTableSortLabel></MudTh>
                <MudTh><MudTableSortLabel SortLabel="Rating" T="AnimeListReadDto">Rating</MudTableSortLabel></MudTh>
                <MudTh Style="width:1%;">Actions</MudTh>
            </HeaderContent>

            <RowTemplate>
                <MudTd DataLabel="Title">@context.Title</MudTd>
                <MudTd DataLabel="Episodes">@context.Episodes</MudTd>
                <MudTd DataLabel="Premiered">@context.Season @context.PremieredYear</MudTd>
                <MudTd DataLabel="Status">@context.Status</MudTd>
                <MudTd DataLabel="Category">@context.CategoryName</MudTd>
                <MudTd DataLabel="Rating">@context.Rating</MudTd>
                <MudTd DataLabel="Actions" Style="white-space:nowrap;">
                    <MudButton Href="@($"anime/update/{context.Id}")" StartIcon="@Icons.Material.Filled.EditNote" Variant="Variant.Filled" Color="Color.Primary">Edit</MudButton>
                    <MudButton @onclick="() => DeleteAnime(context.Id)" StartIcon="@Icons.Material.Filled.Delete" Variant="Variant.Filled" Color="Color.Error">Delete</MudButton>
                </MudTd>
            </RowTemplate>

            <LoadingContent>
                <div class="py-4 text-center">
                    <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
                </div>
            </LoadingContent>

            <PagerContent>
                <MudTablePager />
            </PagerContent>
        </MudTable>
    </MudCardContent>
</MudCard>

@code {
    private List<AnimeListReadDto> AnimesList = new();
    private PagedListMetadata Metadata = new();

    private MudTable<AnimeListReadDto>? MudTable;
    private string SearchTerm { get; set; } = string.Empty;

    private Dictionary<string, string> SortMapping = new()
    {
        {"Title", "title"},
        {"Episodes", "episodes"},
        {"PremieredYear", "premiered"},
        {"Status", "status"},
        {"CategoryName", "categoryname"},
        {"Rating", "rating"}
    };

    // NOTE: MudTable.ServerData expects a Func<TableState, CancellationToken, Task<TableData<T>>>
    private async Task<TableData<AnimeListReadDto>> ServerReload(TableState state, CancellationToken cancellationToken)
    {
        int pageNumber = state.Page + 1;
        int pageSize = state.PageSize;

        string orderBy = "title";
        if (!string.IsNullOrEmpty(state.SortLabel) && SortMapping.ContainsKey(state.SortLabel))
        {
            orderBy = SortMapping[state.SortLabel];

            if (state.SortDirection == SortDirection.Descending)
            {
                orderBy += "_desc";
            }
        }

        var queryParams = new Dictionary<string, string?>
        {
            {"pageNumber", pageNumber.ToString()},
            {"pageSize", pageSize.ToString()},
            {"orderBy", orderBy}
        };

        if (!string.IsNullOrWhiteSpace(SearchTerm))
        {
            queryParams.Add("filterOn", "Title");
            queryParams.Add("filterQuery", SearchTerm);
        }

        var queryString = await new FormUrlEncodedContent(queryParams).ReadAsStringAsync();

        try
        {
            // pass cancellationToken to Http call
            var response = await Http.GetAsync($"api/anime?{queryString}", cancellationToken);
            response.EnsureSuccessStatusCode();

            int totalItems = 0;
            if (response.Headers.TryGetValues("X-Pagination", out var headerValues))
            {
                var metadataJson = headerValues.FirstOrDefault();
                if (!string.IsNullOrWhiteSpace(metadataJson))
                {
                    var metadata = System.Text.Json.JsonSerializer.Deserialize<PagedListMetadata>(metadataJson);
                    totalItems = metadata?.TotalCount ?? 0;
                }
            }

            var items = await response.Content.ReadFromJsonAsync<List<AnimeListReadDto>>(cancellationToken: cancellationToken)
                                ?? new List<AnimeListReadDto>();

            return new TableData<AnimeListReadDto>() { TotalItems = totalItems, Items = items };
        }
        catch (OperationCanceledException)
        {
            // request was cancelled; return empty result
            return new TableData<AnimeListReadDto>() { TotalItems = 0, Items = new List<AnimeListReadDto>() };
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading data: {ex.Message}", Severity.Error);
            return new TableData<AnimeListReadDto>() { TotalItems = 0, Items = new List<AnimeListReadDto>() };
        }
    }

    private async Task OnSearch(string text)
    {
        SearchTerm = text;
        await MudTable!.ReloadServerData();
    }

    private async Task DeleteAnime(int id)
    {
        var parameters = new DialogParameters<ConfirmationDialog>
        {
            { x => x.ContentText, "Are you sure you want to delete?"  },
            { x => x.ButtonText, "Delete" }
        };

        var options = new DialogOptions
        {
            CloseButton = true,
            MaxWidth = MaxWidth.ExtraLarge,
            FullWidth = false,
        };

        var dialog = await Dialog.ShowAsync<ConfirmationDialog>("Confirm Delete", parameters, options);
        var result = await dialog.Result;

        if (result != null && !result.Canceled)
        {
            var response = await Http.DeleteAsync($"api/anime/{id}");
            if (response.IsSuccessStatusCode)
            {
                Snackbar.Add("Anime deleted successfully!", Severity.Success);
                await MudTable!.ReloadServerData();
            }
            else
            {
                Snackbar.Add("Failed to delete anime.", Severity.Error);
            }
        }
    }
}
