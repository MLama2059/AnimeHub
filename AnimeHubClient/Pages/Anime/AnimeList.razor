@page "/anime"
@using AnimeHub.Shared.Models.Dtos
@using AnimeHub.Shared.Models.Dtos.Anime
@using AnimeHubClient.Shared
@using Microsoft.AspNetCore.WebUtilities
@inject HttpClient Http
@inject IDialogService Dialog
@inject ISnackbar Snackbar

@if (IsLoading)
{
    <div class="py-4 text-center"><MudProgressCircular Indeterminate="true" /></div>
}
else
{
    <div class="card shadow border-0 mt-4">
        <div class="card-header bg-black bg-gradient m-lg-0 py-3">
            <div class="row">
                <div class="col-12 text-center">
                    <h2 class="text-white py-2">Anime List</h2>
                </div>
            </div>
        </div>
        <div class="card-body p-4">
            <div class="row align-items-end">
                <div class="col-md-4">
                    <label for="searchBox" class="form-label">Search Title:</label>
                    <div class="input-group">
                        <input type="text"
                               class="form-control"
                               @bind="SearchInput"
                               @bind:event="oninput"
                               @onkeypress="HandleEnterKeySearch"
                               placeholder="Search anime">
                    </div>
                </div>
                <div class="col-md-4">
                    <label for="sortDropdown" class="form-label">Sort By:</label>
                    <select id="sortDropdown" class="form-select" @bind:after="HandleSortChange" @bind="OrderBy">
                        <option value="title">Title (A-Z)</option>
                        <option value="rating">Rating (Highest)</option>
                        <option value="premiered">Premiered (Latest)</option>
                    </select>
                </div>
                <div class="col-md-4 text-end">
                    @* <a href="anime/create" class="btn btn-secondary"><i class="bi bi-plus-square"></i> Add New Anime</a> *@
                    <MudButton Href="anime/create" StartIcon="@Icons.Material.Filled.AddTask" Variant="Variant.Filled" Color="Color.Primary">Add New Anime</MudButton>
                </div>
            </div>
        </div>
        @if (AnimesList != null && AnimesList.Any())
        {
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Title</th>
                            <th>Episodes</th>
                            <th>Priemered</th>
                            <th>Status</th>
                            <th>Category</th>
                            <th>Rating</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var anime in AnimesList)
                        {
                            <tr>
                                <td>@anime.Title</td>
                                <td>@anime.Episodes</td>
                                <td>@anime.Season @anime.PremieredYear</td>
                                <td>@anime.Status</td>
                                <td>@anime.CategoryName</td>
                                <td>@anime.Rating</td>

                                <td class="text-center align-middle">
                                    <div class="d-flex justify-content-center gap-2">
                                        <MudButton Href="@($"anime/update/{anime.Id}")" StartIcon="@Icons.Material.Filled.EditNote" Variant="Variant.Filled" Color="Color.Primary">Edit</MudButton>
                                        <MudButton @onclick="() => DeleteAnime(anime.Id)" StartIcon="@Icons.Material.Filled.Delete" Variant="Variant.Filled" Color="Color.Error">Delete</MudButton>
                                    </div>
                                </td>
                            </tr>
                        }
                    </tbody>
                </table>

                @* --- Pagination Controls --- *@
                <div class="d-flex justify-content-center mt-3">
                    <nav>
                        <ul class="pagination">
                            @* Previous Button *@
                            <li class="page-item @(Metadata.HasPrevious ? null : "disabled")">
                                <button class="page-link"
                                        @onclick="() => ChangePage(Metadata.CurrentPage - 1)"
                                        disabled="@(!Metadata.HasPrevious)">
                                    Previous
                                </button>
                            </li>

                            @* Page Status Display *@
                            <li class="page-item disabled">
                                <span class="page-link">
                                    Page @Metadata.CurrentPage of @Metadata.TotalPages (@Metadata.TotalCount items)
                                </span>
                            </li>

                            @* Next Button *@
                            <li class="page-item @(Metadata.HasNext ? null : "disabled")">
                                <button class="page-link"
                                        @onclick="() => ChangePage(Metadata.CurrentPage + 1)"
                                        disabled="@(!Metadata.HasNext)">
                                    Next
                                </button>
                            </li>
                        </ul>
                    </nav>
                </div>
            </div>
        }
    </div>
}

@code {
    private bool IsLoading { get; set; } = true;
    // private List<AnimeReadDto>? Animes;
    private List<AnimeListReadDto> AnimesList = new();
    private PagedListMetadata Metadata = new();
    private int CurrentPage = 1;
    private int PageSize = 10;
    private string OrderBy { get; set; } = "Title";
    private const string FilterOn = "Title";
    // Properties for Search
    private string FilterQuery { get; set; } = string.Empty; // Actual filter sent to API
    private string SearchInput { get; set; } = string.Empty; // Value from the input box

    protected override async Task OnInitializedAsync()
    {
        // Set initial SearchInput value to match FilterQuery (for consistency)
        SearchInput = FilterQuery;
        await LoadAnimes();
    }

    private async Task LoadAnimes()
    {
        IsLoading = true;
        StateHasChanged();
        try
        {
            // Build the Query String
            var queryParams = new Dictionary<string, string?>
            {
                {"pageNumber", CurrentPage.ToString()},
                {"pageSize", PageSize.ToString()},
                {"orderBy", OrderBy}
            };

            // Add Filter Params if a search query is present
            if (!string.IsNullOrWhiteSpace(FilterQuery))
            {
                queryParams.Add("filterOn", FilterOn);
                queryParams.Add("filterQuery", FilterQuery);
            }

            // Construct the full URL: api/anime?pageNumber=1&pageSize=10...
            var queryString = new FormUrlEncodedContent(queryParams).ReadAsStringAsync().Result;

            var response = await Http.GetAsync($"api/anime?{queryString}");
            response.EnsureSuccessStatusCode();

            // Read Pagination Metadata from the Header
            if (response.Headers.TryGetValues("X-Pagination", out var headerValues))
            {
                var metadataJson = headerValues.FirstOrDefault();
                if (!string.IsNullOrWhiteSpace(metadataJson))
                {
                    Metadata = System.Text.Json.JsonSerializer.Deserialize<PagedListMetadata>(metadataJson) ?? new PagedListMetadata();
                }
            }

            // Read the Anime List from the Body
            AnimesList = await response.Content.ReadFromJsonAsync<List<AnimeListReadDto>>()
                        ?? new List<AnimeListReadDto>();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error fetching category data: {ex.Message}");
        }
        finally
        {
            IsLoading = false;
            StateHasChanged();
        }
    }

    private async Task DeleteAnime(int id)
    {
        var parameters = new DialogParameters<ConfirmationDialog>
        {
            { x => x.ContentText, "Are you sure you want to delete?"  },
            { x => x.ButtonText, "Delete" }
        };

        var options = new DialogOptions
        {
            CloseButton = true,
            MaxWidth = MaxWidth.ExtraLarge,
            FullWidth = false,
        };

        var dialog = await Dialog.ShowAsync<ConfirmationDialog>("Confirm Delete", parameters, options);
        var result = await dialog.Result;

        if (result != null && !result.Canceled)
        {
            // Call API to delete
            var response = await Http.DeleteAsync($"api/anime/{id}");
            if (response.IsSuccessStatusCode)
            {
                Snackbar.Add("Anime deleted successfully!", Severity.Success);
                await LoadAnimes(); // Reload list
            }
            else
            {
                Snackbar.Add("Failed to delete anime.", Severity.Error);
            }
        }
    }

    private async Task ChangePage(int newPage)
    {
        // 1. Basic boundary check (though Metadata.HasNext/HasPrevious handles most of it)
        if (newPage < 1 || newPage > Metadata.TotalPages)
        {
            return;
        }

        // 2. Update the state variable
        CurrentPage = newPage;

        // 3. Reload the data from the API
        await LoadAnimes();
    }

    private async Task HandleSortChange()
    {
        // When the sort order changes, we must reset to the first page (page 1)
        CurrentPage = 1;

        // LoadAnimes handles setting IsLoading and calling StateHasChanged
        await LoadAnimes();
    }

    private async Task HandleEnterKeySearch(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            // Immediately update the official filter property
            FilterQuery = SearchInput;

            // Call the core search method
            await HandleSearch();
        }
    }

    private async Task HandleSearch()
    {
        CurrentPage = 1; // Always reset to page 1 on search
        await LoadAnimes(); // Replace the list
    }
}
