@page "/anime-catalog"
@using AnimeHub.Shared.Models.Dtos
@using Microsoft.AspNetCore.WebUtilities
@inject HttpClient Http
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@implements IDisposable

<MudPaper Elevation="4" Class="mt-4">
    <MudCard>
        <MudCardHeader>
            <CardHeaderContent>
                <MudText Align="Align.Center" Typo="Typo.h4" Class="fw-bold">Anime Catalog</MudText>
            </CardHeaderContent>
        </MudCardHeader>

        <MudCardContent>
            <MudTextField T="string"
                          Placeholder="Search anime"
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.Search"
                          Immediate="true"
                          Clearable="true"
                          Style="max-width:300px;"
                          Value="SearchInput"
                          ValueChanged="@(async (v) => await OnSearchChanged(v))" />
        </MudCardContent>
    </MudCard>

    @* Anime Card Grid and Loading State *@
    <div class="container my-4">
        <div class="col-12 mt-5 pt-5 section-card">
            <div class="row row-cols-1 row-cols-sm-2 row-cols-md-3 row-cols-lg-4 row-cols-xl-5 g-4 justify-content-start">
                @if (IsLoading && AnimesList.Count == 0)
                {
                    @for (int i = 0; i < 6; i++)
                    {
                        <div class="col d-flex justify-content-center">
                            <AnimeCardSkeleton />
                        </div>
                    }
                }
                else if (AnimesList != null && AnimesList.Any())
                {
                    @foreach (var anime in AnimesList)
                    {
                        <div class="col d-flex justify-content-center">
                            <AnimeCard Anime="anime" />
                        </div>
                    }
                }
                else
                {
                    <p class="text-center w-100 p-5">No Results.</p>
                }
            </div>
        </div>

        @* Infinite Scroll Loading Indicator *@
        @if (IsLoading && AnimesList.Count > 0)
        {
            @* Show skeleton cards horizontally only when loading MORE data (list is not empty) *@
            <div class="row row-cols-1 row-cols-sm-2 row-cols-md-3 row-cols-lg-4 row-cols-xl-5 g-4 justify-content-start pt-4">
                @for (int i = 0; i < 6; i++)
                {
                    <div class="col d-flex justify-content-center">
                        <AnimeCardSkeleton />
                    </div>
                }
            </div>
        }
        @* End of List Message *@
        else if (!HasMorePages && AnimesList.Any())
        {
            <MudText Align="Align.Center" Class="py-4 text-muted fw-bold">
                You've reached the end of the catalog! (@AnimesList.Count total items)
            </MudText>
        }
    </div>
</MudPaper>

@code {
    private List<AnimeListReadDto> AnimesList = new();
    private PagedListMetadata Metadata = new();
    private bool IsLoading { get; set; } = true;
    private int CurrentPage { get; set; } = 1;
    private int PageSize { get; set; } = 20;
    private bool HasMorePages { get; set; } = true;
    private string OrderBy { get; set; } = "title";
    private const string FilterOn = "Title";
    // Properties for Debouncing/Search
    private string FilterQuery { get; set; } = string.Empty; // Actual filter sent to API
    private string SearchInput { get; set; } = string.Empty; // Value from the input box
    private CancellationTokenSource _debounceCts = new();

    protected override async Task OnInitializedAsync()
    {
        // Set initial SearchInput value to match FilterQuery (for consistency)
        SearchInput = FilterQuery;
        await LoadAnimes();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Register the .NET method to be called when the user scrolls near the bottom
            await JSRuntime.InvokeVoidAsync("setupInfiniteScroll", DotNetObjectReference.Create(this));
        }
    }

    // --- JS INTEROP METHOD (Called by JavaScript) ---
    [JSInvokable]
    public async Task LoadMoreData()
    {
        // Only load if we aren't already loading and there are more pages available
        if (!IsLoading && HasMorePages)
        {
            CurrentPage++;
            await LoadAnimes(append: true); // Pass a flag to indicate appending
        }
    }

    private async Task LoadAnimes(bool append = false)
    {
        if (append && !HasMorePages) return;

        IsLoading = true;
        if (append) StateHasChanged();

        try
        {
            // await Task.Delay(1000);
            // Build the Query String
            var queryParams = new Dictionary<string, string?>
            {
                {"pageNumber", CurrentPage.ToString()},
                {"pageSize", PageSize.ToString()},
                {"orderBy", OrderBy}
            };

            // Add Filter Params if a search query is present
            if (!string.IsNullOrWhiteSpace(FilterQuery))
            {
                queryParams.Add("filterOn", FilterOn);
                queryParams.Add("filterQuery", FilterQuery);
            }

            var queryString = new FormUrlEncodedContent(queryParams).ReadAsStringAsync().Result;

            var response = await Http.GetAsync($"api/anime?{queryString}");
            response.EnsureSuccessStatusCode();

            var newAnimes = await response.Content.ReadFromJsonAsync<List<AnimeListReadDto>>() ?? new();

            // Append or Replace logic
            if (append)
            {
                AnimesList.AddRange(newAnimes);
            }
            else
            {
                AnimesList = newAnimes;
                CurrentPage = 1;
            }

            // Update Metadata for HasMorePages
            if (response.Headers.TryGetValues("X-Pagination", out var headerValues))
            {
                var metadataJson = headerValues.FirstOrDefault();
                if (!string.IsNullOrWhiteSpace(metadataJson))
                {
                    Metadata = System.Text.Json.JsonSerializer.Deserialize<PagedListMetadata>(metadataJson) ?? new PagedListMetadata();
                    HasMorePages = Metadata.HasNext;
                }
            }
        }
        catch (Exception ex)
        {
            // Console.Error.WriteLine($"Error fetching category data: {ex.Message}");
            Snackbar.Add($"Error loading catalog: {ex.Message}", Severity.Error);
        }
        finally
        {
            IsLoading = false;
            StateHasChanged();
        }
    }

    private async Task OnSearchChanged(string value)
    {
        SearchInput = value;
        // Cancel any pending/previous search operation
        _debounceCts.Cancel();
        _debounceCts = new();

        try
        {
            // Wait for 500ms before calling the API 
            await Task.Delay(200, _debounceCts.Token);

            // Update the *official* filter property used by LoadAnimes
            FilterQuery = SearchInput;
            CurrentPage = 1;
            HasMorePages = true;
            await LoadAnimes();
        }
        catch (TaskCanceledException)
        {
            // Ignore if the task was canceled
        }
    }

    // LIFECYCLE CLEANUP: Prevent memory leaks from the CancellationTokenSource
    public void Dispose()
    {
        _debounceCts.Cancel();
        _debounceCts.Dispose();
    }
}
