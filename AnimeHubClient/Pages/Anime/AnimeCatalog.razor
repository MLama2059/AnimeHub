@page "/animes"
@implements IDisposable
@using AnimeHub.Shared.Models.Dtos
@using AnimeHubClient.Services
@using Microsoft.AspNetCore.WebUtilities
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@inject IAnimeService AnimeService
@inject AnimeStateContainer State

<MudPaper Elevation="4" Class="mt-4">
    <MudCard>
        <MudCardHeader>
            <CardHeaderContent>
                <MudText Align="Align.Center" Typo="Typo.h4" Class="fw-bold">Anime Catalog</MudText>
            </CardHeaderContent>
        </MudCardHeader>

        <MudCardContent>
            <MudTextField T="string"
                          Placeholder="Search anime"
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.Search"
                          Immediate="true"
                          Clearable="true"
                          Style="max-width:300px;"
                          Value="SearchInput"
                          ValueChanged="OnSearchChanged" />
        </MudCardContent>
    </MudCard>

    @* Anime Card Grid - Keeping your exact Bootstrap structure *@
    <div class="container my-4">
        <div class="col-12 mt-5 pt-5 section-card">
            <div class="row row-cols-1 row-cols-sm-2 row-cols-md-3 row-cols-lg-4 row-cols-xl-5 g-4 justify-content-start">

                @if (IsLoading && AnimesList.Count == 0)
                {
                    @for (int i = 0; i < 10; i++)
                    {
                        <div class="col d-flex justify-content-center">
                            <AnimeCardSkeleton />
                        </div>
                    }
                }
                else if (AnimesList.Any())
                {
                    @foreach (var anime in AnimesList)
                    {
                        <div class="col d-flex justify-content-center">
                            <AnimeCard Anime="anime" />
                        </div>
                    }
                }
                else if (!IsLoading)
                {
                    <p class="text-center w-100 p-5">No Results Found for "@FilterQuery"</p>
                }

                @* Infinite Scroll Skeletons - Shows only when fetching next page *@
                @if (IsLoading && AnimesList.Count > 0)
                {
                    @for (int i = 0; i < 5; i++)
                    {
                        <div class="col d-flex justify-content-center">
                            <AnimeCardSkeleton />
                        </div>
                    }
                }
            </div>
        </div>

        @* Invisible trigger for Intersection Observer *@
        <div id="scroll-trigger" style="height: 50px;"></div>

        @if (!HasMorePages && AnimesList.Any())
        {
            <MudText Align="Align.Center" Class="py-4 text-muted fw-bold">
                You've reached the end of the catalog! (@AnimesList.Count total items)
            </MudText>
        }
    </div>
</MudPaper>

<MudScrollToTop>
    <MudFab Color="Color.Primary" StartIcon="@Icons.Material.Filled.ArrowUpward" />
</MudScrollToTop>

@code {
    // State Redirection
    private List<AnimeListReadDto> AnimesList => State.CatalogItems;
    private string FilterQuery { get => State.CatalogSearchTerm; set => State.CatalogSearchTerm = value; }
    private int CurrentPage { get => State.CatalogCurrentPage; set => State.CatalogCurrentPage = value; }
    private bool HasMorePages { get => State.CatalogHasMorePages; set => State.CatalogHasMorePages = value; }

    private string SearchInput = string.Empty;
    private bool IsLoading { get; set; } = false;
    private CancellationTokenSource _debounceCts = new();

    protected override async Task OnInitializedAsync()
    {
        SearchInput = FilterQuery;

        // If coming back from Anime Details, don't reload data
        if (AnimesList.Count == 0)
        {
            await LoadAnimes();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("setupInfiniteScroll", DotNetObjectReference.Create(this));
        }
    }

    private async Task LoadAnimes(bool append = false)
    {
        IsLoading = true;
        StateHasChanged();

        try
        {
            var (newAnimes, metadata) = await AnimeService.GetAnimeCatalogAsync(
                CurrentPage, 20, "title", FilterQuery);

            if (append)
                State.CatalogItems.AddRange(newAnimes ?? new());
            else
                State.CatalogItems = newAnimes ?? new();

            HasMorePages = metadata?.HasNext ?? false;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        finally
        {
            IsLoading = false;
            StateHasChanged();
        }
    }

    private async Task OnSearchChanged(string value)
    {
        SearchInput = value;
        _debounceCts.Cancel();
        _debounceCts = new();

        try
        {
            await Task.Delay(400, _debounceCts.Token);
            FilterQuery = value;
            CurrentPage = 1;
            HasMorePages = true;
            State.CatalogItems.Clear(); // Clear list for new search
            await LoadAnimes(append: false);
        }
        catch (TaskCanceledException) { }
    }

    [JSInvokable]
    public async Task LoadMoreData()
    {
        if (!IsLoading && HasMorePages)
        {
            CurrentPage++;
            await LoadAnimes(append: true);
        }
    }

    public void Dispose()
    {
        _debounceCts.Cancel();
        _debounceCts.Dispose();
    }
}